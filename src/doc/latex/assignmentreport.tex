\documentclass[a4paper,12pt]{article}
%\usepackage[backend=biber, style=ieee, maxnames=2, minnames=1, maxbibnames=2]{biblatex}
%\addbibresource{refs.bib}
%\defcounter{maxnames}{2}
\newcommand{\projectName}{PTAR}
\usepackage[acronym]{glossaries}
\usepackage[T1]{fontenc}
%\usepackage{graphicx}
%\usepackage[nottoc,numbib]{tocbibind}
\usepackage{amsmath}
\usepackage{array}
\usepackage{txfonts}
\usepackage{pdflscape}
\usepackage{longtable}

\newcommand\nonter[1]{\ensuremath{#1\negthinspace s}}

\usepackage{syntax}

%\DefineBibliographyStrings{english}{%
%  references = {References},
%}

\begin{document}
\widowpenalties 1 10000

%Give every section a seperate page.
\let\stdsection\section
\renewcommand\section{\newpage\stdsection}

%Beta code to define a glossary
%\usepackage[xindy]{glossaries}
%\usepackage[toc]{glossaries}
%\newglossaryentry{API}{Application Programming Interface}
%\newglossaryentry{REST}{Representational State Transfer}
%\makeglossaries

\newacronym{API}{API}{Application Programming Interface}
\newacronym{REST}{REST}{Representational State Transfer}
\newacronym{RDBMS}{RDBMS}{Relational Database Management System}
\newacronym{OODBMS}{OODBMS}{Object-Orientated Database Management System}
\newacronym{ORDBMS}{ORDBMS}{Object Relational Database Management System}
\newacronym{SSADM}{SSADM}{Structured Systems Analysis and Design Method}
\newacronym{HATEOAS}{HATEOAS}{Hypermedia as the Engine of Application State}
\newacronym{CRUD}{CRUD}{create, read, update and delete}
\newacronym{XP}{XP}{Extreme Programming}
\newacronym{EVA}{EVA}{Earned Value Analysis}
\newacronym{SDT}{SDT}{syntax-directed translation}
\newacronym{SQL}{SQL}{Structured Query Language}
\newacronym{AI}{AI}{Artificial Intelligence}
\newacronym{NLP}{NLP}{Natural Language Processing}
\newacronym{JSON}{JSON}{JavaScript Object Notation}
\newacronym{UPnP}{UPnP}{Universal Plug and Play}
\newacronym{UUID}{UUID}{Universally unique identifier}
\newacronym{CFG}{CFG}{Context-Free Grammar}
\newacronym{Regex}{Regex}{Regular Expression}
\newacronym{CE305}{CE305}{CE305 - Language and Compilers}

\begin{titlepage}
    \newcommand{\HRule}{\rule{\linewidth}{0.5mm}}
    \begin{center}


        \textsc{\LARGE University of Essex}\\[1.5cm]

        \textsc{\Large Assignment One - Expression Analyser}\\[0.5cm]

% Title
        \HRule \\[0.4cm]
        { \huge \bfseries \gls{CE305} \\[0.4cm] }

        \HRule \\[1.5cm]

% Author and supervisor
        \begin{minipage}{0.4\textwidth}
            \begin{flushleft} \large
                \emph{Author:}\\
                John \textsc{Pulford}
            \end{flushleft}
        \end{minipage}
        \begin{minipage}{0.4\textwidth}
            \begin{flushright} \large
                \emph{Lecturer:} \\
                Dr.~Chris \textsc{Fox}
            \end{flushright}
        \end{minipage}

        \vfill

% Bottom of the page
        {\large \today}

    \end{center}
\end{titlepage}

\tableofcontents
\section{Grammar}
\subsection{Source}
\setlength{\grammarparsep}{20pt plus 1pt minus 1pt} % increase separation between rules
\setlength{\grammarindent}{12em} % increase separation between LHS/RHS
\subsubsection{Tokens}

All possible tokens:

{\setlength\tabcolsep{4pt}
\begin{longtable}{>{$}l<{$}>{$}r<{$}>{$}l<{$}}
  TOKEN &\Coloneqq &SEMICOLON\\% bad spacing
  &| &ASSIGN\\% bad spacing
  &| &EQUALS\\% bad spacing
  &| &GREATERTHAN\\% bad spacing
  &| &LESSTHAN\\% bad spacing
  &| &LESSTHANOREQUALS\\% bad spacing
  &| &GREATERTHANOREQUALS\\% bad spacing
  &| &NOTEQUALS\\% bad spacing
  &| &INTTYPE\\% bad spacing
  &| &FLOATTYPE\\% bad spacing
  &| &LEFTCURLY\\% bad spacing
  &| &RIGHTCURLY\\% bad spacing
  &| &IF\\% bad spacing
  &| &TRUE\\% bad spacing
  &| &FALSE\\% bad spacing
  &| &OR\\% bad spacing
  &| &AND\\% bad spacing
  &| &ELSE\\% bad spacing
  &| &WHILE\\% bad spacing
  &| &DEF\\% bad spacing
  &| &COMMA\\% bad spacing
  &| &ID\\% bad spacing
  &| &MUL\\% bad spacing
  &| &DIV\\% bad spacing
  &| &PLUS\\% bad spacing
  &| &MINUS\\% bad spacing
  &| &LEFTPAREN\\% bad spacing
  &| &RIGHTPAREN\\% bad spacing
  &| &FLOATEXPONENT\\% bad spacing
  &| &FLOAT\\% bad spacing
  &| &INT\\% bad spacing
  &| &DIGIT\\% bad spacing
\end{longtable}}
\newpage
Each individual token:

{\setlength\tabcolsep{4pt}
\begin{longtable}{>{$}l<{$}>{$}r<{$}>{$}l<{$}}
  SEMICOLON &\Coloneqq &';'\\% bad spacing
  ASSIGN &\Coloneqq &':='\\% bad spacing
  EQUALS &\Coloneqq &'='\\% bad spacing
  GREATERTHAN &\Coloneqq &'>'\\% bad spacing
  LESSTHAN &\Coloneqq &'<'\\% bad spacing
  LESSTHANOREQUALS &\Coloneqq &'<='\\% bad spacing
  GREATERTHANOREQUALS &\Coloneqq &'>='\\% bad spacing
  NOTEQUALS &\Coloneqq &'!='\\% bad spacing
  INTTYPE &\Coloneqq &'int'\\% bad spacing
  FLOATTYPE &\Coloneqq &'float'\\% bad spacing
  LEFTCURLY &\Coloneqq &'\{'\\% bad spacing
  RIGHTCURLY &\Coloneqq &'\}'\\% bad spacing
  IF &\Coloneqq &'if'\\% bad spacing
  TRUE &\Coloneqq &'true'\\% bad spacing
  FALSE &\Coloneqq &'false'\\% bad spacing
  OR &\Coloneqq &'or'\\% bad spacing
  AND &\Coloneqq &'and'\\% bad spacing
  ELSE &\Coloneqq &'else'\\% bad spacing
  WHILE &\Coloneqq &'while'\\% bad spacing
  DEF &\Coloneqq &'def'\\% bad spacing
  COMMA &\Coloneqq &','\\% bad spacing
  ID &\Coloneqq &[ \; A-z \; ]\\% bad spacing
  MUL &\Coloneqq &'*'\\% bad spacing
  DIV &\Coloneqq &'\backslash'\\% bad spacing
  PLUS &\Coloneqq &'+'\\% bad spacing
  MINUS &\Coloneqq &'-'\\% bad spacing
  LEFTPAREN &\Coloneqq &'('\\% bad spacing
  RIGHTPAREN &\Coloneqq &')'\\% bad spacing
  FLOATEXPONENT &\Coloneqq &'e'\\% bad spacing
  FLOAT &\Coloneqq &INT \; FLOATEXPONENT \; ( \; MINUS \; | \; PLUS \; )? \; INT\\% bad spacing
  INT &\Coloneqq &DIGIT \; DIGIT+\\% bad spacing
  DIGIT &\Coloneqq &[ \; 0-9 \; ]\\% bad spacing
\end{longtable}}
\begin{landscape}
\subsubsection{Expressions}

{\setlength\tabcolsep{4pt}
\begin{longtable}{>{$}l<{$}>{$}r<{$}>{$}l<{$}}
  start &\Coloneqq & func* \; sequence \; func*\\
  func &\Coloneqq & DEF \; ID \; LEFTPAREN \; funcArgs? \; RIGHTPAREN \; LEFTCURLY \; sequence \; RIGHTCURLY\\
  funcArgs &\Coloneqq & declaration \; (COMMA \; declaration)*\\
  declaration &\Coloneqq & valueType \; ID\\
  valueType &\Coloneqq & INTTYPE \; FLOATTYPE\\
  sequence &\Coloneqq & (declaration \; SEMICOLON?)* \; statement*\\
  statement &\Coloneqq & loop\\
  &| &conditional\\% bad spacing
  &| &funcCall \; SEMICOLON\\% bad spacing
  &| &assignment \; SEMICOLON\\% bad spacing
  bool &\Coloneqq & expr \; compOp \; expr\\
  &| &TRUE\\% bad spacing
  &| &FALSE\\% bad spacing
  &| &bool \; boolOp \; bool\\% bad spacing
  &| &LEFTPAREN \; BOOL \; RIGHTPAREN\\% bad spacing
  boolOp &\Coloneqq & (OR \; | \; AND)\\
  compOp &\Coloneqq & (EQUALS \; | \; GREATERTHAN \; | \; LESSTHAN \; | \; NOTEQUALS \; | \; LESSTHANOREQUALS \; | \; GREATERTHANOREQUALS)\\
  &| &expr \; SEMICOLON\\% bad spacing
  loop &\Coloneqq & WHILE \; LEFTPAREN \; bool \; RIGHTPAREN \; LEFTCURLY \; sequence \; RIGHTCURLY\\
  conditional &\Coloneqq & IF \; LEFTPAREN \; bool \; RIGHTPAREN \; LEFTCURLY \; sequence \; RIGHTCURLY\\
  &| & IF \; LEFTPAREN \; bool \; RIGHTPAREN \; LEFTCURLY \; sequence \; RIGHTCURLY\\
  & & ELSE \; LEFTCURLY \; SEQUENCE \; RIGHTCURLY\\
  funcCall &\Coloneqq & ID \; LEFTPAREN \; (expr \; (COMMA \; expr)*)? \; RIGHTPAREN\\
  assignment &\Coloneqq & ID \; ASSIGN \; expr\\
  expr &\Coloneqq & expr \; PLUS \; expr\\
  &| &expr \; DIV \; expr\\% bad spacing
  &| &expr \; MUL \; expr\\% bad spacing
  &| &expr \; MINUS \; expr\\% bad spacing
  &| &MINUS \; FLOAT\\% bad spacing
  &| &PLUS? \; FLOAT\\% bad spacing
  &| &MINUS \; INT\\% bad spacing
  &| &PLUS? \; INT\\% bad spacing
  &| &PLUS? \; LEFTPAREN \; expr \; RIGHTPAREN\\% bad spacing
  &| &MINUS \; LEFTPAREN \; expr \; RIGHTPAREN\\% bad spacing
\end{longtable}}
\subsection{Target Language}
A formal description of the target language is below note that extra language aspects such as loops and conditional statements are not mentioned as the compile will never convert any of the source language into such tokens / statements.

%Provide a formalisation of the target language in (E)BNF.
\subsubsection{Tokens}


{\setlength\tabcolsep{4pt}
\begin{longtable}{>{$}l<{$}>{$}r<{$}>{$}l<{$}}
  TOKEN &\Coloneqq &FLOATMUL\\% bad spacing
  &| &FLOATDIV\\% bad spacing
  &| &FLOATPLUS\\% bad spacing
  &| &FLOATMINUS\\% bad spacing
  &| &FLOATPOP\\% bad spacing
  &| &FLOATPUSHTOADDRESS\\% bad spacing
  &| &PUSHTOADDRESS\\% bad spacing
  &| &EQUALS\\% bad spacing
  &| &GREATERTHAN\\% bad spacing
  &| &LESSTHAN\\% bad spacing
  &| &LESSTHANOREQUALS\\% bad spacing
  &| &GREATERTHANOREQUALS\\% bad spacing
  &| &NOTEQUALS\\% bad spacing
  &| &TRUE\\% bad spacing
  &| &FALSE\\% bad spacing
  &| &OR\\% bad spacing
  &| &AND\\% bad spacing
  &| &VARIABLEDEC\\% bad spacing
  &| &ID\\% bad spacing
  &| &FLOATVALUEOFVARIABLE\\% bad spacing
  &| &VALUEOFVARIABLE\\% bad spacing
  &| &IF\\% bad spacing
  &| &ELSE\\% bad spacing
  &| &ENDIF\\% bad spacing
  &| &BEGIN\\% bad spacing
  &| &WHILE\\% bad spacing
  &| &REPEAT\\% bad spacing
  &| &COLON\\% bad spacing
  &| &SEMICOLON\\% bad spacing
  &| &MUL\\% bad spacing
  &| &DIV\\% bad spacing
  &| &PLUS\\% bad spacing
  &| &MINUS\\% bad spacing
  &| &POP\\% bad spacing
  &| &FLOATEXPONENT\\% bad spacing
  &| &FLOAT\\% bad spacing
  &| &INT\\% bad spacing
  &| &DIGIT\\% bad spacing
  &| &SEPERATOR\\% bad spacing
\end{longtable}}


{\setlength\tabcolsep{4pt}
\begin{longtable}{>{$}l<{$}>{$}r<{$}>{$}l<{$}}
  MUL &\Coloneqq &'*'\\% bad spacing
  DIV &\Coloneqq &'\backslash'\\% bad spacing
  PLUS &\Coloneqq &'+'\\% bad spacing
  MINUS &\Coloneqq &'-'\\% bad spacing
  POP &\Coloneqq &'.'\\% bad spacing
  EQUALS &\Coloneqq &'='\\% bad spacing
  GREATERTHAN &\Coloneqq &'>'\\% bad spacing
  LESSTHAN &\Coloneqq &'<'\\% bad spacing
  LESSTHANOREQUALS &\Coloneqq &'<='\\% bad spacing
  GREATERTHANOREQUALS &\Coloneqq &'>='\\% bad spacing
  TRUE &\Coloneqq &'true'\\% bad spacing
  FALSE &\Coloneqq &'false'\\% bad spacing
  OR &\Coloneqq &'or'\\% bad spacing
  AND &\Coloneqq &'and'\\% bad spacing
  NOTEQUALS &\Coloneqq &'!='\\% bad spacing
  FLOATMUL &\Coloneqq &'f*'\\% bad spacing
  FLOATDIV &\Coloneqq &'f\backslash'\\% bad spacing
  FLOATPLUS &\Coloneqq &'f+'\\% bad spacing
  FLOATMINUS &\Coloneqq &'f-'\\% bad spacing
  FLOATPUSHTOADDRESS &\Coloneqq &'f!'\\% bad spacing
  PUSHTOADDRESS &\Coloneqq &'!'\\% bad spacing
  VARIABLEDEC &\Coloneqq &'variable'\\% bad spacing
  ID &\Coloneqq &[ \; A-z \; ]\\% bad spacing
  FLOATVALUEOFVARIABLE &\Coloneqq &'f@'\\% bad spacing
  VALUEOFVARIABLE &\Coloneqq &'@'\\% bad spacing
  IF &\Coloneqq &'if'\\% bad spacing
  ELSE &\Coloneqq &'else'\\% bad spacing
  ENDIF &\Coloneqq &'endif'\\% bad spacing
  BEGIN &\Coloneqq &'begin'\\% bad spacing
  WHILE &\Coloneqq &'while'\\% bad spacing
  REPEAT &\Coloneqq &'repeat'\\% bad spacing
  COLON &\Coloneqq &':'\\% bad spacing
  SEMICOLON &\Coloneqq &';'\\% bad spacing
  FLOATPOP &\Coloneqq &'f.'\\% bad spacing
  FLOATEXPONENT &\Coloneqq &'e'\\% bad spacing
  FLOAT &\Coloneqq &INT \; FLOATEXPONENT \; ( \; MINUS \; | \; PLUS \; )? \; INT\\% bad spacing
  INT &\Coloneqq &DIGIT \; DIGIT+\\% bad spacing
  DIGIT &\Coloneqq &[ \; 0-9 \; ]\\% bad spacing
  SEPERATOR &\Coloneqq &'\ '\\% bad spacing
\end{longtable}}
\subsubsection{Expression}

Whilst not strictly true I've modeled the grammar of Forth as one that will either except integer or float numbers. This is true from the perspective of this compiler but in reality there is the option of conversion to float within the forth language.

{\setlength\tabcolsep{4pt}
\begin{longtable}{>{$}l<{$}>{$}r<{$}>{$}l<{$}}
  start &\Coloneqq & expr \; | \; floatexpr\\
  expr &\Coloneqq & expr \; expr \; PLUS\\
  &| &expr \; expr \; DIV\\% bad spacing
  &| &expr \; expr \; MUL\\% bad spacing
  &| &expr \; expr \; MINUS\\% bad spacing
  &| &MINUS \; INT\\% bad spacing
  &| &PLUS? \; INT\\% bad spacing
  floatexpr &\Coloneqq & floatexpr \; floatexpr \; FLOATPLUS\\
  &| &floatexpr \; floatexpr \; FLOATDIV\\% bad spacing
  &| &floatexpr \; floatexpr \; FLOATMUL\\% bad spacing
  &| &floatexpr \; floatexpr \; FLOATMINUS\\% bad spacing
  &| &MINUS \; FLOAT\\% bad spacing
  &| &PLUS? \; FLOAT\\% bad spacing
\end{longtable}}
\section{Translation}
\subsection{Tokens}
Rather than cover tokens seperately I simply cover their translation in the expression section for brevity.
\subsection{Expression}

The rule tables follow. The first column signifies the production rule. The second is how it is represented in the source language. The third is the semantic rule for that particular representation i.e the order the nodes are visited and the output of that production rule traversal which results in a Forth compatible grammar. The terminals in this column refer to forth terminals. Non-terminals refer to the source language. (Although both languages have the exact same terminals).

There are also are two versions of the syntax directed translation. One when at least one floating number exists in the source and one when they do not.

\subsubsection{Float Enabled Translation}

{\setlength\tabcolsep{4pt}
\begin{longtable}{>{$}l<{$}>{$}r<{$}>{$}l<{$}|>{$}l<{$}}
  Production & & Source &Target\\ \hline
  start &\Coloneqq & expr_{1}& expr_{1} \; SEPERATOR \; FLOATPOP\\
  expr &\Coloneqq & expr_{1} \; PLUS \; expr_{2}& expr_{1} \; SEPERATOR \; expr_{2} \; SEPERATOR \; FLOATPLUS\\
  &| &expr_{1} \; DIV \; expr_{2}&expr_{1} \; SEPERATOR \; expr_{2} \; SEPERATOR \; FLOATDIV\\% bad spacing
  &| &expr_{1} \; MUL \; expr_{2}&expr_{1} \; SEPERATOR \; expr_{2} \; SEPERATOR \; FLOATMUL\\% bad spacing
  &| &expr_{1} \; MINUS \; expr_{2}&expr_{1} \; SEPERATOR \; expr_{2} \; SEPERATOR \; FLOATMINUS\\% bad spacing
  &| &MINUS \; FLOAT&MINUS \;FLOAT\\% bad spacing
  &| &ADD? \; FLOAT&FLOAT\\% bad spacing
  &| &MINUS \; INT&MINUS \; FLOAT(INT'e0')\\% bad spacing
  &| &ADD? \; INT&FLOAT(INT'e0')\\% bad spacing
  &| &PLUS? \; LEFTPAREN \; expr \; RIGHTPAREN&expr\\% bad spacing
  &| &MINUS \; LEFTPAREN \; expr \; RIGHTPAREN&'0e0' \; SEPERATOR \; expr \; SEPERATOR \; - \\% bad spacing
\end{longtable}}

\subsubsection{Float Disabled Translation}

{\setlength\tabcolsep{4pt}
\begin{longtable}{>{$}l<{$}>{$}r<{$}>{$}l<{$}|>{$}l<{$}}
  Production & & Source &Target\\ \hline
  start &\Coloneqq & func* \; sequence \; func*& declarationList \; functionList \; T[sequence] \\
  func &\Coloneqq & DEF \; ID \; LEFTPAREN \; funcArgs? & functionList.append(COLON \; SEPERATOR \; ID \; SEPERATOR\\ 
  & & RIGHTPAREN \; LEFTCURLY \; sequence&sequence \; SEMICOLON \; SEPERATOR)\\
  & & RIGHTCURLY \; sequence \; RIGHTCURLY& \\
  funcArgs &\Coloneqq & declaration \; (COMMA \; declaration)*& T[declaration_{1..n}] \\
  declaration &\Coloneqq & valueType \; ID& scope.define(a) \; declarationList.append(VARIABLE \; SEPERATOR \; scope.resolve(a) )\\
  valueType &\Coloneqq & INTTYPE \; FLOATTYPE&TODOREMOVETHIS \\
  sequence &\Coloneqq & (declaration \; SEMICOLON?)* \; statement*& T[declaration_{1..n}] \; T[statement_{1..n}]\\
  statement &\Coloneqq & loop& \\
  &| &conditional& \\% bad spacing
  &| &funcCall \; SEMICOLON& \\% bad spacing
  &| &assignment \; SEMICOLON& \\% bad spacing
  bool &\Coloneqq & expr \; compOp \; expr& \\
  &| &TRUE& \\% bad spacing
  &| &FALSE& \\% bad spacing
  &| &bool \; boolOp \; bool& \\% bad spacing
  &| &LEFTPAREN \; BOOL \; RIGHTPAREN& \\% bad spacing
  boolOp &\Coloneqq & (OR \; | \; AND)& \\
  compOp &\Coloneqq & (EQUALS \; | \; GREATERTHAN \; | & \\
  & & LESSTHAN \; | \; NOTEQUALS \; | \; & \\
  & & LESSTHANOREQUALS \; |& \\
  & & GREATERTHANOREQUALS)& \\
  &| &expr \; SEMICOLON& \\% bad spacing
  loop &\Coloneqq & WHILE \; LEFTPAREN \; bool& \\
  & & RIGHTPAREN \; LEFTCURLY& \\
  & & sequence \; RIGHTCURLY& \\
  conditional &\Coloneqq & IF \; LEFTPAREN \; bool \\
  & & RIGHTPAREN \; LEFTCURLY \\
  & & sequence \; RIGHTCURLY& \\
  &| & IF \; LEFTPAREN \; bool& \\
  & & RIGHTPAREN \; LEFTCURLY& \\
  & & sequence \; RIGHTCURLY& \\
  & & ELSE \; LEFTCURLY& \\
  & & SEQUENCE \; RIGHTCURLY& \\
  funcCall &\Coloneqq & ID \; LEFTPAREN \\
  & & (expr \; (COMMA \; expr)*)? \; RIGHTPAREN& \\
  assignment &\Coloneqq & ID \; ASSIGN \; expr& \\
  expr &\Coloneqq & expr_{1} \; PLUS \; expr_{2}& expr_{1} \; SEPERATOR \; expr_{2} \; SEPERATOR \; PLUS\\
  &| &expr_{1} \; DIV \; expr_{2}&expr_{1} \; SEPERATOR \; expr_{2} \; SEPERATOR \; DIV\\% bad spacing
  &| &expr_{1} \; MUL \; expr_{2}&expr_{1} \; SEPERATOR \; expr_{2} \; SEPERATOR \; MUL\\% bad spacing
  &| &expr_{1} \; MINUS \; expr_{2}&expr_{1} \; SEPERATOR \; expr_{2} \; SEPERATOR \; MINUS\\% bad spacing
  &| &MINUS \; INT&MINUS \; INT\\% bad spacing
  &| &ADD? \; INT&INT\\% bad spacing
  &| &PLUS? \; LEFTPAREN \\
  & & expr \; RIGHTPAREN&expr\\% bad spacing
  &| &MINUS \; LEFTPAREN \\ 
  & & expr \; RIGHTPAREN&'0' \; SEPERATOR \; expr \; SEPERATOR \; - \\% bad spacing
\end{longtable}}

%This could probably be merged into Expressions
\section{Implementation}
\subsection{Running}
To build, test and run with arguments use.
\begin{quotation}
./gradlew clean release run -Pargs="example.if"
\end{quotation}
Simply change "example.if" to another filepath to run with said file.

NOTE: Not applicable to university computers, unfortunately. Instead, to run the precompiled jar:


\begin{quotation}
\begin{verbatim}
java -jar build/distributions/small-compiler-unspecified-shadow.jar example.if
\end{verbatim}

\end{quotation}

The compiler will generate two files.
\begin{quotation}
<filename>.fs and <filename>.ps
\end{quotation}
The former is the target code generated from the input file. The latter is a postscript parse tree representing the calls within the program. Note that ANTLR4 does not list the types of terminal characters and thus this is not technically a concrete syntax tree.

\end{landscape}
\subsection{Tools}
An ANTLR4 grammar was written and then compiled to generate a Parser and Lexer. Then the base visitor class was extended to generate the source string and control the order non-terminals were visited in. Graphing was also generated via ANTLR. Error handling was done by extending ANTLR's error handling classes and extending the \gls{CFG} with error catching. ANTLR4 grammar files have extensive enhancements over traditional grammars. Ignoring whitespace was achieved with one
line. Precedence is implicit; ANTLR4 uses the first matching production rule when going left to right in the document. So by writing the * and / expressions out first they will always be compiled before a + or - expression.

Less significantly other tools were applied but mainly applied to the work flow.
\begin{itemize}
    \item JUnit was used for unit testing compiler output against target language output.
    \item Gradle was used for the build script, it compiles the ANTLR files, then my java files, then unit tests them, packages up the program as a jar and finally runs it with my specified arguments.
    \item An awaiting-approval plugin for Gradle known as shadowJar which generates fat jars; jars that contain all of their dependencies.
    \item A crude attempt at an ANTLR4 plugin for Gradle from Github was transformed into an actual gradle plugin and used to facilitate the build script's existence.
    \item A equally crude attempt at an LaTeX plugin for Gradle from Github was transformed into an actual gradle plugin to facilitate the build script's existence (And improved upon).
    \item These plugins implementations can be found inside buildSrc/. They were written when it became evident that LaTeX and ANTLR4 would be part of third year project build script, they'll be made open source once both deadlines have passed.
\end{itemize}

\subsection{Extended Features}
The following has been implemented;
\begin{description}
    \item[A visual reading of a parse tree] \hfill
        Although as mentioned it is missing terminal types.
    \item[Support for floating-point expressions as well as integers] \hfill
        Integers are converted into floats when floats are in the equation; the lexer is applied twice to achieve this.
    \item[Helpful and informative error messages]
        Due to the behaviour-driven development used for this software the best way to see what error cases are supported is to access src/test/java/CompilerShouldError.java. Each test function is written in human readable camel case.
    \item[Immune to whitespace]
       Whitespace doesn't matter, check the unit tests for whacky spacing examples. This required a specific structuring of the grammar because in antlr4 you cannot implicitly ignore whitespace inside terminals (Which is why there are no signed numbers as terminals).
\end{description}

Code has been divided, code inside:
\begin{quotation}
src -> generated
\end{quotation}
Is generated by antlr during a build.


Code that is inside:
\begin{quotation}
src -> main
\end{quotation}
\begin{quotation}
src -> test
\end{quotation}
was written by me, this code also contains comments for further information.

Code that is inside:
\begin{quotation}
buildSrc
\end{quotation}
was written by me, this is the code for the aforementioned plugins I developed and is not of particular importance.

\end{document}
